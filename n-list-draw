emulate -L zsh

zmodload zsh/curses
zmodload zsh/regex

setopt localoptions
setopt typesetsilent

_nlist_expand_tabs() {
    local chunk="$1"
    integer before_len="$2"
    REPLY=""
    local tab=$'\t'

    while [ ! -z "$chunk" ]; do
        up_to_tab="${chunk%%$tab*}"
        if [ "$up_to_tab" != "$chunk" ]; then
            local remaining="${chunk[$#up_to_tab+2,-1]}"
            integer left_len="$#up_to_tab"
            integer tabs_count_all=$(( (before_len+left_len)/8 ))
            integer all_text_len=$(( (tabs_count_all+1)*8 ))
            integer chunk_padded_len=$(( all_text_len - before_len ))
            REPLY+="${(r:$chunk_padded_len:: :)up_to_tab}"

            before_len+=chunk_padded_len
            chunk="$remaining"
        else
            REPLY+="$chunk"
            break
        fi
    done
}

_nlist_print_with_ansi() {
    local win="$1"
    local text="$2"
    integer max_text_len="$3"
    integer text_len=0
    local regex=$'([^\x1b]*)\x1b\\[([0-9]{1,2};)?([0-9]{1,2})?m(.*)'

    # 1 - non-escaped text, 2 - first number in the escaped text, with ;
    # 3 - second number, 4 - text after whole escape text

    local out
    integer no_match=0
    typeset -a c
    c=( black red green yellow blue magenta cyan white )

    while [[ ! -z "$text" && "$no_match" -eq 0 ]]; do
        if [[ "$text" -regex-match "$regex" ]]; then
            text="$match[4]"
            out="$match[1]"
        else
            out="$text"
            no_match=1
        fi

        if [ ! -z "$out" ]; then
            _nlist_expand_tabs "$out" "$text_len"
            out="$REPLY"

            text_len+="$#out"
            [[ "$text_len" -gt "$max_text_len" ]] && out="${out[1,-1*(text_len-max_text_len+1)]}"
            zcurses string "$win" "$out"
        fi

        if [ "$no_match" -eq 0 ]; then
            if [[ "$match[3]" -ge 30 && "$match[3]" -le 37 ]]; then
                zcurses attr "$win" $c[$(( match[3] - 29 ))]/black
            elif [[ ! -z "$match[3]" && "$match[3]" -eq 0 ]]; then
                zcurses attr "$win" white/black
            fi
        fi
    done
    zcurses attr "$win" white/black
}

integer highlight="$1"
integer start_idx="$2"
integer page_height="$3"
integer page_width="$4"
local y_offset="$5"
local x_offset="$6"
local win="$7"
local ansi_mode="$8"
shift 8
integer max_text_len=page_width-x_offset


local -a list
list=( "$@" )

integer end_idx=start_idx+page_height-1
[ "$end_idx" -gt "$#list" ] && end_idx="$#list"
integer y=y_offset

integer i
for (( i=start_idx; i<=end_idx; i++ )); do
    zcurses move "$win" $y "$x_offset"

    local text="$list[$i]"

    [ "$i" = "$highlight" ] && zcurses attr "$win" +reverse
    if [ "$ansi_mode" != "ansi" ]; then
        _nlist_expand_tabs "$list[$i]"
        text="$REPLY"
        integer text_len="${#text}"

        [ "$text_len" -gt "$max_text_len" ] && text="${text[1,$max_text_len]}"
        zcurses string "$win" "$text"
    else
        _nlist_print_with_ansi "$win" "$text" "$max_text_len"
    fi
    [ "$i" = "$highlight" ] && zcurses attr "$win" -reverse

    y+=1
done

# vim: set filetype=zsh:
