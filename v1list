# $1 - output variable name
# $2, $3, ... - elements of the list
# $VLIST_NONSELECTABLE_ELEMENTS - array of indexes (1-based) that cannot be selected
#
# Copy this file into /usr/share/zsh/[-version-]/functions
# and add 'autoload v1list` to .zshrc
#
# This function outputs a list of elements that can be
# navigated with keyboard. Uses curses library

emulate -L zsh

zmodload zsh/curses

setopt localtraps
trap "return" TERM INT QUIT
trap "_vlist_exit" EXIT

# Cleanup before any exit
_vlist_exit() {
    unset _from_what_idx_list_is_shown
    zcurses delwin main
    zcurses refresh
    zcurses end
}

# Outputs a message in the bottom of the screen
_vlist_status_msg() {
    zcurses move main $(( term_height - 2 )) 2
    zcurses string main "                        "
    zcurses move main $(( term_height - 2 )) 2
    zcurses string main "$1"
}

# Outputs the list
_vlist_list() {
    # Use only local scope
    integer highlight="$1"
    integer page_size="$2"
    shift 2

    local -a list
    list=( "$@" )

    integer start_idx=_from_what_idx_list_is_shown
    integer end_idx=start_idx+page_size-1
    [ "$end_idx" -gt "$#list" ] && end_idx="$#list"
    integer y=1

    zcurses clear main
    zcurses border main

    integer i
    for (( i=start_idx; i<=end_idx; i++ )); do
        zcurses move main $y 2

        [ "$i" = "$highlight" ] && zcurses attr main +reverse
        zcurses string main "$list[$i]"
        [ "$i" = "$highlight" ] && zcurses attr main -reverse

        y+=1

        #_vlist_status_msg "highlight $highlight, last $last_element, i $i, start_idx $start_idx, end_idx $end_idx"
        _vlist_status_msg "Current #$highlight (of #$last_element entries)"
    done
}

# Variables from this file are still in the scope
check_if_previous_page() {
    if [ "$current" -lt "$_from_what_idx_list_is_shown" ]; then
        _from_what_idx_list_is_shown=_from_what_idx_list_is_shown-page_size 
        [ "$_from_what_idx_list_is_shown" -lt 1 ] && _from_what_idx_list_is_shown=1
    fi
}

# Variables from this file are still in the scope
# The last_shown_idx_of_the_list variable is local to this scope
check_if_next_page() {
    integer last_shown_idx_of_the_list=_from_what_idx_list_is_shown+page_size-1
    if [ "$last_shown_idx_of_the_list" -gt "$last_element" ]; then
        last_shown_idx_of_the_list=last_element
    fi

    # Next page?
    if [ "$current" -gt "$last_shown_idx_of_the_list" ]; then
        _from_what_idx_list_is_shown=_from_what_idx_list_is_shown+page_size 
        if [ "$_from_what_idx_list_is_shown" -gt "$last_element" ]; then
            _from_what_idx_list_is_shown=last_element
        fi
    fi
}

#
# Main code
#

integer term_width=$(stty size | cut -f2 -d " ")
integer term_height=$(stty size | cut -f1 -d " ")
integer page_size=term_height-3
integer _from_what_idx_list_is_shown=1
integer current=1

# Ability to remember the list between calls - code block 1/3
if [ "$VLIST_REMEMBER_LIST" -gt 0 ]; then
    [ ! -z "$VLIST_FROM_WHAT_IDX_LIST_IS_SHOWN" ] && _from_what_idx_list_is_shown="$VLIST_FROM_WHAT_IDX_LIST_IS_SHOWN"
    [ ! -z "$VLIST_CURRENT_IDX_OF_THE_LIST" ] && current="$VLIST_CURRENT_IDX_OF_THE_LIST"
fi

local result_var="$1"
shift
eval "$result_var=-1"
integer last_element="$#"

zcurses init
zcurses addwin main "$term_height" "$term_width" 0 0

#
# Listening for input
#

while (( 1 )); do
    # Output the list
    _vlist_list "$current" "$page_size" "$@"
    zcurses refresh

    # Wait for input
    zcurses input main key keypad mouse

    # Get the special (i.e. "keypad") key or regular key
    if [ ! -z "$key" ]; then
        final_key="$key" 
    elif [ ! -z "$keypad" ]; then
        final_key="$keypad"
    else
        _vlist_status_msg "Inproper input detected"
        zcurses refresh
    fi

    case "$final_key" in
        (UP|k)
            # Are there any elements before the current one?
            [ "$current" -gt 1 ] && current=current-1;
            # Previous page?
            check_if_previous_page
            ;;
        (DOWN|j)
            # Are there any elements after the current one?
            [ "$current" -lt "$last_element" ] && current=current+1;
            # Next page?
            check_if_next_page
            ;;
        (PPAGE)
            current=current-page_size
            [ "$current" -lt 1 ] && current=1;
            check_if_previous_page
            ;;
        (NPAGE|" ")
            current=current+page_size
            [ "$current" -gt "$last_element" ] && current=last_element;
            check_if_next_page
            ;;
        (HOME)
            current=1
            _from_what_idx_list_is_shown=1
            ;;
        (END)
            current=last_element
            _from_what_idx_list_is_shown=last_element-page_size+1
            [ "$_from_what_idx_list_is_shown" -lt 1 ] && _from_what_idx_list_is_shown=1;
            ;;
        ($'\n')
            # Is that element selectable?
            if [[ ${VLIST_NONSELECTABLE_ELEMENTS[(r)$current]} != $current ]]; then
                # Save current element in the result variable
                _vlist_status_msg "Selecting element #$current"
                zcurses refresh
                eval "$result_var=$current"

                # Ability to remember the list between calls - code block 2/3
                if [ "$VLIST_REMEMBER_LIST" -gt 0 ]; then
                    VLIST_FROM_WHAT_IDX_LIST_IS_SHOWN="$_from_what_idx_list_is_shown"
                    VLIST_CURRENT_IDX_OF_THE_LIST="$current"
                fi
                break
            fi
            ;;
        (q)
            _vlist_status_msg "Quit (no selection)"
            zcurses refresh

            # Ability to remember the list between calls - code block 3/3
            if [ "$VLIST_REMEMBER_LIST" -gt 0 ]; then
                VLIST_FROM_WHAT_IDX_LIST_IS_SHOWN="$_from_what_idx_list_is_shown"
                VLIST_CURRENT_IDX_OF_THE_LIST="$current"
            fi
            break
        (*)
            _vlist_status_msg "Inproper input detected"
            zcurses refresh
            ;;
    esac
done

# vim: set filetype=zsh:
